<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√âditeur de Positions des Cartes de Tarot</title>
    <link rel="stylesheet" href="./assets/css/base/variables.css">
    <!-- 
    *******************************************************
    * √âDITEUR DE POSITIONS DES CARTES DE TAROT
    *******************************************************
    * 
    * Cet outil permet de d√©finir visuellement les positions des cartes
    * pour les diff√©rents types de tirages de JodoTarot.
    * 
    * PRINCIPES ARCHITECTURAUX:
    * 1. Utilise les variables CSS de variables.css comme source unique de v√©rit√©
    * 2. Ne red√©finit jamais les variables d√©j√† pr√©sentes dans variables.css
    * 3. G√©n√®re des variables CSS √† copier dans variables.css
    * 4. Adapte ses dimensions automatiquement selon les media queries
    *
    * UTILISATION:
    * - S√©lectionnez un type de tirage dans le menu d√©roulant
    * - D√©placez les cartes √† la position souhait√©e
    * - Ajustez la rotation si n√©cessaire
    * - Copiez le CSS g√©n√©r√© et collez-le dans variables.css
    * 
    * D√âPENDANCES:
    * - ../assets/css/base/variables.css (dimensions et styles de base)
    *
    -->
    <style>
        :root {
            /* Reprise des variables du fichier panels.css */
            --spread-width: 650px;
            --spread-height: 800px;
            /* Ne pas red√©finir les variables de couleur ou de cartes d√©j√† dans variables.css */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f7;
            height: 100vh;
            overflow: hidden;
        }

        #app {
            display: flex;
            gap: 20px;
            max-width: 1600px; /* Augment√© pour avoir plus d'espace */
            margin: 0 auto;
            height: calc(100vh - 40px); /* Utilise toute la hauteur disponible */
        }

        #workspace {
            /* Reprise exacte des styles du spread-panel de JodoTarot */
            flex: 0 0 var(--spread-width);
            width: var(--spread-width);
            min-width: var(--spread-width);
            height: var(--spread-height);
            max-height: var(--spread-height);
            display: flex;
            justify-content: flex-start;
            align-items: flex-start;
            position: relative;
            padding: 0;
            margin: var(--spacing-lg, 12px) 0 var(--spacing-lg, 12px) var(--spacing-sm, 6px);
            background-color: var(--color-table-green, #a0d5b5);
            border-radius: var(--border-radius-md, 8px);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            box-sizing: border-box;
        }

        #controls {
            width: 400px; /* Un peu plus large */
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            height: var(--spread-height);
            overflow-y: auto;
        }

        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: white;
            border: 2px solid var(--color-primary);
            border-radius: calc(var(--card-width) * 0.05);  /* Utiliser la m√™me formule que dans cards.css */
            position: absolute;
            cursor: move;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #333;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            padding: 5px;
            z-index: 1;
        }

        .card .position-number {
            font-weight: bold;
            font-size: 18px;
            color: var(--color-primary);
            margin-bottom: 5px;
            transform: none;
            pointer-events: none;
        }

        .card .card-name {
            font-weight: bold;
            margin-bottom: 2px;
            transform: none;
            pointer-events: none;
        }

        .card .card-description {
            font-size: 10px;
            text-align: center;
            color: #666;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            max-width: 90%;
            transform: none;
            pointer-events: none;
        }

        .card.selected {
            border-color: var(--color-success);
            box-shadow: 0 0 0 2px var(--color-success);
            z-index: 10;
            filter: brightness(1.08);
        }

        .card:hover {
            z-index: 10;
            filter: brightness(1.08);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
            transform: scale(1.02);
        }

        select, button, input {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        select {
            font-weight: bold;
            color: var(--color-primary);
            background-color: #f5f5f7;
            border-left: 3px solid var(--color-primary);
        }

        button {
            background: var(--color-primary);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }

        button:hover {
            background: #534672;
        }

        #output {
            margin-top: 10px;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 100%;
            height: calc(100% - 40px); /* Utilise tout l'espace disponible */
            overflow-y: auto;
            transition: background-color 0.2s ease-in-out;
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
            border: 1px solid #eaeaea;
        }
        
        #output.updating {
            background-color: #e9f5e9;
            border-left: 3px solid var(--color-success);
        }

        .coordinates {
            margin-top: 5px;
            margin-bottom: 10px;
            font-size: 14px;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            text-align: center;
        }
        
        .rotation-control {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
            flex-direction: column;
        }
        
        .rotation-control input {
            width: 100%;
            margin-top: 5px;
        }
        
        .rotation-value {
            font-weight: bold;
            color: var(--color-primary);
        }
        
        /* Grouper les contr√¥les pour gagner de l'espace */
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .output-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .output-container h3 {
            color: var(--color-primary);
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        /* Styles responsifs similaires √† ceux de JodoTarot */
        @media (max-width: 1200px) {
            #app {
                flex-direction: column;
                align-items: center;
            }
            
            #workspace {
                margin: var(--spacing-lg, 12px) auto;
            }
            
            #controls {
                width: var(--spread-width, 650px);
                max-width: 100%;
            }
        }
        
        @media (max-width: 768px) {
            #workspace {
                width: 100%;
                max-width: 600px;
                min-width: 320px;
            }
            
            #controls {
                width: 100%;
                max-width: 600px;
            }
        }
        
        /* Adaptations des cartes selon le Media Query similaires √† JodoTarot */
        @media (max-width: 576px) {
            /* Cette section n'est plus n√©cessaire car nous utilisons les variables CSS directement
               Les variables sont d√©j√† ajust√©es par les media queries dans variables.css */
        }
        
        @media (max-width: 400px) {
            /* Cette section n'est plus n√©cessaire car nous utilisons les variables CSS directement
               Les variables sont d√©j√† ajust√©es par les media queries dans variables.css */
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="workspace"></div>
        <div id="controls">
            <div class="control-group">
                <select id="spreadType">
                    <option value="cross">‚ûï Tirage en Croix</option>
                    <option value="horseshoe">üß≤ Fer √† Cheval</option>
                    <option value="love">‚ù§Ô∏è Tarot de l'amour</option>
                    <option value="celtic">‚òòÔ∏è Croix Celtique</option>
                </select>
                <div class="button-group" style="display: flex; gap: 10px; margin-bottom: 10px;">
                    <button id="resetBtn" style="flex: 1;">R√©initialiser</button>
                    <button id="copyBtn" style="flex: 1;">Copier CSS</button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="rotation-control">
                    <label for="rotationSlider">Rotation: <span id="rotationValue" class="rotation-value">0¬∞</span></label>
                    <input type="range" id="rotationSlider" min="0" max="360" value="0" step="5">
                </div>
            </div>
            
            <!-- Nouveau contr√¥le pour les dimensions des cartes -->
            <div class="control-group">
                <h3 style="margin: 5px 0; font-size: 14px;">Dimensions des Cartes:</h3>
                <div class="card-dimension-control">
                    <label for="cardBaseWidth">Largeur de base (px): <span id="cardBaseWidthValue">95</span></label>
                    <input type="range" id="cardBaseWidth" min="60" max="150" value="95" step="5">
                </div>
                <div class="card-dimension-control">
                    <label for="cardRatio">Ratio hauteur/largeur: <span id="cardRatioValue">1.7</span></label>
                    <input type="range" id="cardRatio" min="1.4" max="2.0" value="1.7" step="0.1">
                </div>
                <div class="card-dimension-control">
                    <label for="cardScaleFactor">Facteur d'√©chelle: <span id="cardScaleFactorValue">1</span></label>
                    <input type="range" id="cardScaleFactor" min="0.8" max="1.5" value="1" step="0.1">
                </div>
            </div>
            
            <div class="output-container">
                <h3 style="margin: 5px 0; font-size: 14px;">Variables CSS:</h3>
                <div id="output"></div>
            </div>
        </div>
    </div>

    <script>
        /**
         * D√©finition des types de tirages disponibles
         * Structure: 
         * - name: Nom affich√© du tirage
         * - cards: Tableau des cartes avec leur nom technique, label d'affichage, position et description
         */
        const spreads = {
            cross: {
                name: 'Tirage en Croix',
                cards: [
                    { name: 'center', label: 'Centre', position: 1, description: 'La situation centrale' },
                    { name: 'top', label: 'Haut', position: 2, description: 'L\'influence sup√©rieure' },
                    { name: 'right', label: 'Droite', position: 3, description: 'Ce qui arrive' },
                    { name: 'bottom', label: 'Bas', position: 4, description: 'La fondation' },
                    { name: 'left', label: 'Gauche', position: 5, description: 'Ce qui s\'en va' }
                ]
            },
            horseshoe: {
                name: 'Fer √† Cheval',
                cards: [
                    { name: 'past', label: 'Pass√©', position: 1, description: 'Le pass√© lointain' },
                    { name: 'recent', label: 'R√©cent', position: 2, description: 'Le pass√© r√©cent' },
                    { name: 'present', label: 'Pr√©sent', position: 3, description: 'Le pr√©sent' },
                    { name: 'future', label: 'Futur', position: 4, description: 'Le futur proche' },
                    { name: 'outcome', label: 'R√©sultat', position: 5, description: 'Le r√©sultat probable' },
                    { name: 'influences', label: 'Influences', position: 6, description: 'Les influences externes' },
                    { name: 'advice', label: 'Conseil', position: 7, description: 'Les conseils' }
                ]
            },
            love: {
                name: 'Tirage de l\'Amour',
                cards: [
                    { name: 'you', label: 'Vous', position: 1, description: 'Votre position dans la relation' },
                    { name: 'partner', label: 'Partenaire', position: 2, description: 'La position de votre partenaire' },
                    { name: 'relationship', label: 'Relation', position: 3, description: 'La dynamique actuelle' },
                    { name: 'foundation', label: 'Fondation', position: 4, description: 'La base de la relation' },
                    { name: 'past', label: 'Pass√©', position: 5, description: 'L\'histoire pass√©e' },
                    { name: 'present', label: 'Pr√©sent', position: 6, description: 'La situation pr√©sente' },
                    { name: 'future', label: 'Futur', position: 7, description: 'L\'√©volution future' }
                ]
            },
            celtic: {
                name: 'Croix Celtique',
                cards: [
                    { name: 'present', label: 'Pr√©sent', position: 1, description: 'Situation actuelle' },
                    { name: 'challenge', label: 'D√©fi', position: 2, description: 'Obstacle ou d√©fi imm√©diat' },
                    { name: 'crown', label: 'Couronne', position: 5, description: 'Influence consciente/Objectifs' },
                    { name: 'foundation', label: 'Fondation', position: 3, description: 'Base de la situation' },
                    { name: 'past', label: 'Pass√©', position: 4, description: 'Pass√© r√©cent/Ce qui s\'en va' },
                    { name: 'future', label: 'Futur', position: 6, description: 'Futur proche/Ce qui vient' },
                    { name: 'self', label: 'Soi', position: 7, description: 'Votre attitude/Comment vous √™tes per√ßu' },
                    { name: 'environment', label: 'Environnement', position: 8, description: 'Influences ext√©rieures' },
                    { name: 'hopes', label: 'Espoirs', position: 9, description: 'Esp√©rances ou craintes' },
                    { name: 'outcome', label: 'R√©sultat', position: 10, description: 'R√©sultat final' }
                ]
            }
        };

        /**
         * Variables globales et √©l√©ments DOM
         */
        let selectedCard = null;
        let cardPositions = {}; // Structure de donn√©es pour stocker les positions de toutes les cartes
        let initialCardPositions = {};
        
        // √âl√©ments DOM principaux
        const workspace = document.getElementById('workspace');
        const spreadSelect = document.getElementById('spreadType');
        const output = document.getElementById('output');
        const rotationSlider = document.getElementById('rotationSlider');
        const rotationValue = document.getElementById('rotationValue');

        /**
         * Fonctions utilitaires pour manipuler les variables CSS
         * Ces fonctions standardisent l'acc√®s aux variables CSS dans tout le code
         */
        // Fonction am√©lior√©e pour extraire les valeurs des variables CSS
        function getComputedCSSVariable(variableName) {
            // Standardisation: utiliser toujours cette fonction pour r√©cup√©rer les valeurs CSS
            return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
        }
        
        // Nouvelle fonction utilitaire pour extraire la valeur avec son unit√© (%, px, deg, etc.)
        function getCSSVariableWithUnit(variableName) {
            return getComputedCSSVariable(variableName);
        }
        
        // Fonction pour extraire une valeur num√©rique sans unit√©
        function getCSSVariableNumeric(variableName) {
            const value = getComputedCSSVariable(variableName);
            // Extraction de la valeur num√©rique quelle que soit l'unit√© (%, px, deg, etc.)
            const numericValue = parseFloat(value);
            return isNaN(numericValue) ? 0 : numericValue;
        }

        // Fonction pour charger les positions initiales depuis variables.css
        function loadInitialPositions() {
            const spreadTypes = ['cross', 'horseshoe', 'love', 'celtic'];
            
            // Positions par d√©faut selon le type de tirage pour une meilleure distribution visuelle
            const defaultPositions = {
                cross: {
                    center: { x: 50, y: 50, rotation: 0 },
                    top: { x: 50, y: 20, rotation: 0 },
                    right: { x: 80, y: 50, rotation: 0 },
                    bottom: { x: 50, y: 80, rotation: 0 },
                    left: { x: 20, y: 50, rotation: 0 }
                },
                horseshoe: {
                    past: { x: 20, y: 70, rotation: 0 },
                    recent: { x: 30, y: 50, rotation: 0 },
                    present: { x: 50, y: 40, rotation: 0 },
                    future: { x: 70, y: 50, rotation: 0 },
                    outcome: { x: 80, y: 70, rotation: 0 },
                    influences: { x: 65, y: 85, rotation: 0 },
                    advice: { x: 35, y: 85, rotation: 0 }
                },
                love: {
                    you: { x: 30, y: 30, rotation: 0 },
                    partner: { x: 70, y: 30, rotation: 0 },
                    relationship: { x: 50, y: 40, rotation: 0 },
                    foundation: { x: 50, y: 70, rotation: 0 },
                    past: { x: 30, y: 60, rotation: 0 },
                    present: { x: 50, y: 55, rotation: 0 },
                    future: { x: 70, y: 60, rotation: 0 }
                },
                celtic: {
                    present: { x: 40, y: 40, rotation: 0 },
                    challenge: { x: 50, y: 40, rotation: 90 },
                    crown: { x: 45, y: 10, rotation: 0 },
                    foundation: { x: 45, y: 70, rotation: 0 },
                    past: { x: 20, y: 40, rotation: 0 },
                    future: { x: 70, y: 40, rotation: 0 },
                    self: { x: 85, y: 15, rotation: 0 },
                    environment: { x: 85, y: 30, rotation: 0 },
                    hopes: { x: 85, y: 45, rotation: 0 },
                    outcome: { x: 85, y: 60, rotation: 0 }
                }
            };
            
            spreadTypes.forEach(spreadType => {
                cardPositions[spreadType] = {};
                initialCardPositions[spreadType] = {};
                
                spreads[spreadType].cards.forEach(card => {
                    // V√©rifier d'abord les variables standardis√©es
                    const xVarName = `--${spreadType}-position-${card.position}-x`;
                    const yVarName = `--${spreadType}-position-${card.position}-y`;
                    const rotationVarName = `--${spreadType}-position-${card.position}-rotation`;
                    
                    // Utiliser les nouvelles fonctions standardis√©es
                    let x = getCSSVariableNumeric(xVarName);
                    let y = getCSSVariableNumeric(yVarName);
                    let rotation = getCSSVariableNumeric(rotationVarName);
                    
                    // Si les variables standardis√©es n'existent pas, essayer les anciennes
                    if (isNaN(x) || isNaN(y)) {
                        const oldXVarName = `--${spreadType}-${card.name}-x`;
                        const oldYVarName = `--${spreadType}-${card.name}-y`;
                        const oldRotationVarName = `--${spreadType}-${card.name}-rotation`;
                        
                        x = getCSSVariableNumeric(oldXVarName);
                        y = getCSSVariableNumeric(oldYVarName);
                        rotation = getCSSVariableNumeric(oldRotationVarName);
                    }
                    
                    // Utiliser les valeurs par d√©faut sp√©cifiques au tirage si elles sont disponibles
                    const defaultX = defaultPositions[spreadType]?.[card.name]?.x || 50;
                    const defaultY = defaultPositions[spreadType]?.[card.name]?.y || 50;
                    const defaultRotation = defaultPositions[spreadType]?.[card.name]?.rotation || 0;
                    
                    // Valeur par d√©faut si la variable n'existe pas ou n'est pas un nombre valide
                    cardPositions[spreadType][card.name] = {
                        x: isNaN(x) ? defaultX : x,
                        y: isNaN(y) ? defaultY : y,
                        rotation: isNaN(rotation) ? defaultRotation : rotation
                    };
                    
                    // Stocker √©galement les valeurs initiales pour comparaison ult√©rieure
                    initialCardPositions[spreadType][card.name] = {
                        x: isNaN(x) ? defaultX : x,
                        y: isNaN(y) ? defaultY : y,
                        rotation: isNaN(rotation) ? defaultRotation : rotation
                    };
                });
            });
            
            // Charger aussi les dimensions des cartes depuis variables.css
            loadCardDimensionsFromCSS();
            
            console.log('Positions initiales et dimensions charg√©es:', cardPositions);
        }
        
        // Fonction pour charger les dimensions des cartes depuis variables.css
        function loadCardDimensionsFromCSS() {
            // Toujours utiliser la valeur actuelle du s√©lecteur
            const spreadType = spreadSelect.value;
            console.log(`Chargement des dimensions pour ${spreadType} depuis loadCardDimensionsFromCSS`);
            
            // R√©cup√©rer les dimensions sp√©cifiques au tirage depuis variables.css
            // Essayer d'abord les variables sp√©cifiques au tirage
            let baseWidth = getCSSVariableNumeric(`--${spreadType}-card-base-width`);
            let ratio = getCSSVariableNumeric(`--${spreadType}-card-ratio`);
            let scaleFactor = getCSSVariableNumeric(`--${spreadType}-card-scale-factor`);
            
            // Si les variables sp√©cifiques n'existent pas, utiliser les variables globales
            if (isNaN(baseWidth)) baseWidth = getCSSVariableNumeric('--card-base-width') || 95;
            if (isNaN(ratio)) ratio = getCSSVariableNumeric('--card-ratio') || 1.7;
            if (isNaN(scaleFactor)) scaleFactor = getCSSVariableNumeric('--card-scale-factor') || 1;
            
            console.log(`Dimensions charg√©es pour ${spreadType}:`, { baseWidth, ratio, scaleFactor });
            
            // Mettre √† jour les curseurs
            cardBaseWidth.value = baseWidth;
            cardRatio.value = ratio;
            cardScaleFactor.value = scaleFactor;
            
            // Mettre √† jour les affichages textuels
            cardBaseWidthValue.textContent = baseWidth;
            cardRatioValue.textContent = ratio;
            cardScaleFactorValue.textContent = scaleFactor;
            
            // Appliquer ces dimensions au document
            document.documentElement.style.setProperty(`--${spreadType}-card-base-width`, `${baseWidth}px`);
            document.documentElement.style.setProperty(`--${spreadType}-card-ratio`, ratio);
            document.documentElement.style.setProperty(`--${spreadType}-card-scale-factor`, scaleFactor);
            
            // Appliquer aussi aux variables globales pour la compatibilit√©
            document.documentElement.style.setProperty('--card-base-width', `${baseWidth}px`);
            document.documentElement.style.setProperty('--card-ratio', ratio);
            document.documentElement.style.setProperty('--card-scale-factor', scaleFactor);
            
            // G√©n√©rer le CSS pour les dimensions
            generateCardDimensionsCSS();
        }

        // Fonction pour g√©n√©rer le CSS des dimensions des cartes
        function generateCardDimensionsCSS() {
            const spreadType = spreadSelect.value;
            let css = "";
            
            // G√©n√©rer les variables sp√©cifiques au tirage
            css += `--${spreadType}-card-base-width: ${cardBaseWidth.value}px;\n`;
            css += `--${spreadType}-card-ratio: ${cardRatio.value};\n`;
            css += `--${spreadType}-card-scale-factor: ${cardScaleFactor.value};\n`;
            
            // G√©n√©rer les variables globales pour la compatibilit√©
            css += `--card-base-width: ${cardBaseWidth.value}px;\n`;
            css += `--card-ratio: ${cardRatio.value};\n`;
            css += `--card-scale-factor: ${cardScaleFactor.value};\n`;
            
            return css;
        }

        /**
         * Cr√©e un √©l√©ment DOM repr√©sentant une carte de tarot
         * @param {Object} card - D√©finition de la carte depuis l'objet spreads
         * @param {number} index - Index de la carte dans le tableau
         * @returns {HTMLElement} - √âl√©ment DOM repr√©sentant la carte
         */
        function createCard(card, index) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            cardEl.dataset.name = card.name;
            cardEl.dataset.position = card.position;
            
            // Cr√©er les √©l√©ments internes avec le num√©ro de position et la description
            const positionEl = document.createElement('div');
            positionEl.className = 'position-number';
            positionEl.textContent = card.position;
            
            const nameEl = document.createElement('div');
            nameEl.className = 'card-name';
            nameEl.textContent = card.label;
            
            const descriptionEl = document.createElement('div');
            descriptionEl.className = 'card-description';
            descriptionEl.textContent = card.description;
            
            // Ajouter les √©l√©ments √† la carte
            cardEl.appendChild(positionEl);
            cardEl.appendChild(nameEl);
            cardEl.appendChild(descriptionEl);
            
            // Position par d√©faut au centre (sera √©cras√©e si une position existe)
            cardEl.style.left = '50%';
            cardEl.style.top = '50%';
            cardEl.style.transform = 'translate(-50%, -50%)';
            
            cardEl.addEventListener('mousedown', startDragging);
            return cardEl;
        }

        /**
         * G√®re le d√©but du glisser-d√©poser d'une carte
         * Configure les gestionnaires d'√©v√©nements pour le mouvement et la fin du glisser
         * @param {MouseEvent} e - √âv√©nement de clic souris
         */
        function startDragging(e) {
            // S√©lectionner la carte parente, peu importe o√π le clic a √©t√© fait
            if (selectedCard) {
                selectedCard.classList.remove('selected');
            }
            
            // Utiliser e.currentTarget pour obtenir l'√©l√©ment sur lequel l'√©v√©nement a √©t√© attach√©
            // et non l'√©l√©ment sur lequel l'utilisateur a cliqu√©
            selectedCard = e.currentTarget;
            selectedCard.classList.add('selected');

            // R√©cup√©rer la rotation actuelle de la carte s√©lectionn√©e
            const name = selectedCard.dataset.name;
            const spreadType = spreadSelect.value;
            const rotation = cardPositions[spreadType]?.[name]?.rotation || 0;
            
            // Mettre √† jour le slider de rotation
            rotationSlider.value = rotation;
            rotationValue.textContent = `${rotation}¬∞`;

            const rect = workspace.getBoundingClientRect();
            
            // Mettre en √©vidence la zone de sortie et la garder en √©vidence pendant le d√©placement
            output.classList.add('updating');
            
            // Garantir que les positions sont initialis√©es
            if (!cardPositions[spreadType]) {
                cardPositions[spreadType] = {};
            }
            if (!cardPositions[spreadType][name]) {
                cardPositions[spreadType][name] = { 
                    x: parseFloat(selectedCard.style.left) || 50, 
                    y: parseFloat(selectedCard.style.top) || 50,
                    rotation: rotation 
                };
            }
            
            // Variable pour suivre l'√©tat du glisser-d√©poser
            let isDragging = true;
            
            function onMouseMove(e) {
                if (!selectedCard || !isDragging) return;
                
                // V√©rifier si le bouton de la souris est toujours enfonc√©
                // Si buttons === 0, cela signifie qu'aucun bouton n'est enfonc√©
                if (e.buttons === 0) {
                    onMouseUp();
                    return;
                }
                
                const rect = workspace.getBoundingClientRect();
                
                const x = ((e.clientX - rect.left) / rect.width) * 100;
                const y = ((e.clientY - rect.top) / rect.height) * 100;
                
                // Limiter les valeurs entre 0 et 100
                const boundedX = Math.max(0, Math.min(100, x));
                const boundedY = Math.max(0, Math.min(100, y));
                
                selectedCard.style.left = boundedX + '%';
                selectedCard.style.top = boundedY + '%';
                
                // Conserver la rotation dans la transformation mais sans animation
                const name = selectedCard.dataset.name;
                const spreadType = spreadSelect.value;
                const rotation = cardPositions[spreadType][name].rotation || 0;
                selectedCard.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;

                // Sauvegarder la position imm√©diatement
                if (!cardPositions[spreadType]) {
                    cardPositions[spreadType] = {};
                }
                if (!cardPositions[spreadType][name]) {
                    cardPositions[spreadType][name] = { rotation: 0 };
                }
                cardPositions[spreadType][name].x = boundedX;
                cardPositions[spreadType][name].y = boundedY;
                
                // Forcer la mise √† jour du texte CSS √† chaque mouvement
                updateOutput(true);
            }

            function onMouseUp() {
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                document.removeEventListener('blur', onWindowBlur);
                
                // Retirer la mise en √©vidence de la sortie apr√®s un court d√©lai
                setTimeout(() => {
                    output.classList.remove('updating');
                }, 300);
                
                // S'assurer que la sortie est √† jour une derni√®re fois
                updateOutput(false);
            }
            
            // G√©rer la perte de focus de la fen√™tre pendant le glissement
            function onWindowBlur() {
                // Terminer le glisser-d√©poser proprement quand la fen√™tre perd le focus
                if (isDragging) {
                    onMouseUp();
                }
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('blur', onWindowBlur);
            
            // Emp√™cher la propagation de l'√©v√©nement pour √©viter des comportements ind√©sirables
            e.preventDefault();
            e.stopPropagation();
        }

        // Gestion de la rotation
        rotationSlider.addEventListener('input', function() {
            if (!selectedCard) return;
            
            const rotation = parseInt(this.value);
            rotationValue.textContent = `${rotation}¬∞`;
            
            const name = selectedCard.dataset.name;
            const spreadType = spreadSelect.value;
            
            // Appliquer la rotation √† la carte
            selectedCard.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
            
            // Sauvegarder la rotation
            if (!cardPositions[spreadType]) {
                cardPositions[spreadType] = {};
            }
            if (!cardPositions[spreadType][name]) {
                cardPositions[spreadType][name] = { x: 50, y: 50 };
            }
            cardPositions[spreadType][name].rotation = rotation;
            
            // Mettre en √©vidence la sortie
            output.classList.add('updating');
            setTimeout(() => output.classList.remove('updating'), 300);
            
            // Mise √† jour imm√©diate
            updateOutput(true);
        });

        // Gestion des dimensions des cartes
        const cardBaseWidth = document.getElementById('cardBaseWidth');
        const cardRatio = document.getElementById('cardRatio');
        const cardScaleFactor = document.getElementById('cardScaleFactor');
        const cardBaseWidthValue = document.getElementById('cardBaseWidthValue');
        const cardRatioValue = document.getElementById('cardRatioValue');
        const cardScaleFactorValue = document.getElementById('cardScaleFactorValue');
        
        // Charger les valeurs actuelles depuis les variables CSS
        // Au lieu de charger les variables globales, charger les variables sp√©cifiques au tirage initial
        // qui est celui s√©lectionn√© par d√©faut dans le menu d√©roulant
        const initialSpreadType = spreadSelect.value;
        let initialBaseWidth = getCSSVariableNumeric(`--${initialSpreadType}-card-base-width`);
        let initialRatio = getCSSVariableNumeric(`--${initialSpreadType}-card-ratio`);
        let initialScaleFactor = getCSSVariableNumeric(`--${initialSpreadType}-card-scale-factor`);
        
        // Si les variables sp√©cifiques n'existent pas, utiliser les variables globales
        if (isNaN(initialBaseWidth)) initialBaseWidth = getCSSVariableNumeric('--card-base-width') || 95;
        if (isNaN(initialRatio)) initialRatio = getCSSVariableNumeric('--card-ratio') || 1.7;
        if (isNaN(initialScaleFactor)) initialScaleFactor = getCSSVariableNumeric('--card-scale-factor') || 1;
        
        cardBaseWidth.value = initialBaseWidth;
        cardRatio.value = initialRatio;
        cardScaleFactor.value = initialScaleFactor;
        cardBaseWidthValue.textContent = initialBaseWidth;
        cardRatioValue.textContent = initialRatio;
        cardScaleFactorValue.textContent = initialScaleFactor;
        
        // Variable pour le debounce
        let dimensionChangeTimeout = null;
        
        // Mise √† jour des valeurs affich√©es avec debounce pour √©viter trop de rechargements
        cardBaseWidth.addEventListener('input', function() {
            cardBaseWidthValue.textContent = this.value;
            debounceDimensionChange();
        });
        
        cardRatio.addEventListener('input', function() {
            cardRatioValue.textContent = this.value;
            debounceDimensionChange();
        });
        
        cardScaleFactor.addEventListener('input', function() {
            cardScaleFactorValue.textContent = this.value;
            debounceDimensionChange();
        });
        
        // Fonction de debounce pour √©viter trop d'appels rapproch√©s
        function debounceDimensionChange() {
            clearTimeout(dimensionChangeTimeout);
            const spreadType = spreadSelect.value;
            
            // Appliquer imm√©diatement les styles sans recalculer
            // Variables sp√©cifiques au tirage
            document.documentElement.style.setProperty(`--${spreadType}-card-base-width`, `${cardBaseWidth.value}px`);
            document.documentElement.style.setProperty(`--${spreadType}-card-ratio`, cardRatio.value);
            document.documentElement.style.setProperty(`--${spreadType}-card-scale-factor`, cardScaleFactor.value);
            
            // Variables globales pour la compatibilit√©
            document.documentElement.style.setProperty('--card-base-width', `${cardBaseWidth.value}px`);
            document.documentElement.style.setProperty('--card-ratio', cardRatio.value);
            document.documentElement.style.setProperty('--card-scale-factor', cardScaleFactor.value);
            
            // Attendre un peu avant de recharger compl√®tement (pour une meilleure performance)
            dimensionChangeTimeout = setTimeout(() => {
                applyCardDimensions();
            }, 300);
        }
        
        // Fonction pour appliquer les dimensions en temps r√©el
        function applyCardDimensions() {
            console.log("Applying card dimensions:", {
                width: cardBaseWidth.value,
                ratio: cardRatio.value,
                scaleFactor: cardScaleFactor.value
            });
            
            // G√©n√©rer les variables CSS pour les dimensions des cartes
            updateCardSizeOutput();
            
            // Recharger le spread pour appliquer les nouvelles dimensions
            loadSpread();
            
            // Forcer une mise √† jour de l'affichage CSS apr√®s le rechargement
            updateOutput(false);
        }
        
        // Fonction pour g√©n√©rer les variables CSS des dimensions des cartes
        function updateCardSizeOutput() {
            // Ne pas g√©n√©rer le CSS ici, car updateOutput() va d√©j√† le faire
            // Mettre √† jour directement l'affichage CSS via updateOutput
            updateOutput(false);
        }

        // Fonction pour comparer deux valeurs avec une tol√©rance pour les nombres
        function hasChanged(val1, val2, tolerance = 0.5) {
            // Convertir en nombres si possible pour assurer une comparaison coh√©rente
            const num1 = typeof val1 === 'number' ? val1 : parseFloat(val1);
            const num2 = typeof val2 === 'number' ? val2 : parseFloat(val2);
            
            // Si les deux valeurs peuvent √™tre converties en nombres valides
            if (!isNaN(num1) && !isNaN(num2)) {
                return Math.abs(num1 - num2) > tolerance;
            }
            
            // Pour les autres types ou si la conversion √©choue, comparaison stricte
            return val1 !== val2;
        }

        // Fonction pour g√©n√©rer le CSS des variables de position
        function generatePositionCSS(spreadType, position) {
            // Si les positions n'existent pas, utiliser des valeurs par d√©faut
            if (!cardPositions[spreadType] || !cardPositions[spreadType][position.name]) {
                return '';
            }
            
            let css = '';
            const pos = cardPositions[spreadType][position.name];
            
            // Utiliser le format standardis√© des variables de position
            const formattedX = `--${spreadType}-position-${position.position}-x: ${Math.round(pos.x)}%;\n`;
            const formattedY = `--${spreadType}-position-${position.position}-y: ${Math.round(pos.y)}%;\n`;
            
            css += formattedX;
            css += formattedY;
            
            // Ajouter la rotation si n√©cessaire
            if (pos.rotation && pos.rotation !== 0) {
                css += `--${spreadType}-position-${position.position}-rotation: ${pos.rotation}deg;\n`;
            }
            
            return css;
        }

        /**
         * Charge un type de tirage dans l'espace de travail
         * Cr√©e les cartes, positionne les selon les donn√©es enregistr√©es
         * et met √† jour l'affichage CSS
         */
        function loadSpread() {
            // R√©initialiser imm√©diatement le texte CSS au d√©but de la fonction
            resetCSSOutput();
            
            workspace.innerHTML = '';
            const spreadType = spreadSelect.value;
            const spread = spreads[spreadType];
            
            // D√©s√©lectionner la carte actuelle
            selectedCard = null;
            
            // R√©initialiser le contr√¥le de rotation
            rotationSlider.value = 0;
            rotationValue.textContent = "0¬∞";
            
            // Synchroniser les contr√¥leurs de dimensions avec les valeurs sp√©cifiques au tirage
            // Essayer d'abord de charger les dimensions sp√©cifiques au tirage
            let baseWidth = getCSSVariableNumeric(`--${spreadType}-card-base-width`);
            let ratio = getCSSVariableNumeric(`--${spreadType}-card-ratio`);
            let scaleFactor = getCSSVariableNumeric(`--${spreadType}-card-scale-factor`);
            
            // Si les dimensions sp√©cifiques n'existent pas, utiliser les dimensions globales
            if (isNaN(baseWidth)) baseWidth = getCSSVariableNumeric('--card-base-width') || 95;
            if (isNaN(ratio)) ratio = getCSSVariableNumeric('--card-ratio') || 1.7;
            if (isNaN(scaleFactor)) scaleFactor = getCSSVariableNumeric('--card-scale-factor') || 1;
            
            console.log(`Chargement des dimensions pour le tirage ${spreadType}:`, { baseWidth, ratio, scaleFactor });
            
            cardBaseWidth.value = baseWidth;
            cardRatio.value = ratio;
            cardScaleFactor.value = scaleFactor;
            cardBaseWidthValue.textContent = baseWidth;
            cardRatioValue.textContent = ratio;
            cardScaleFactorValue.textContent = scaleFactor;
            
            // Adaptation sp√©cifique par type de tirage
            switch(spreadType) {
                case 'cross':
                    workspace.className = 'spread';
                    break;
                case 'horseshoe':
                    workspace.className = 'horseshoe-spread';
                    break;
                case 'love':
                    workspace.className = 'love-spread';
                    break;
                case 'celtic':
                    workspace.className = 'celtic-cross-spread';
                    break;
            }
            
            spread.cards.forEach((card, index) => {
                const cardEl = createCard(card, index);
                workspace.appendChild(cardEl);
                
                // Ajouter la classe correspondant au type de carte
                cardEl.classList.add(card.name);
                
                // Restore saved position and rotation if exists
                if (cardPositions[spreadType]?.[card.name]) {
                    const pos = cardPositions[spreadType][card.name];
                    cardEl.style.left = pos.x + '%';
                    cardEl.style.top = pos.y + '%';
                    
                    // Appliquer la rotation si elle existe
                    const rotation = pos.rotation || 0;
                    cardEl.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
                }
            });
            
            // Ne pas r√©initialiser l'affichage CSS ici, car cela peut causer un √©cran blanc
            // resetCSSOutput();
            output.classList.remove('updating');
        }
        
        /**
         * R√©initialise la zone d'affichage du CSS au message par d√©faut
         */
        function resetCSSOutput() {
            // Ne pas vider compl√®tement le contenu si des variables doivent √™tre affich√©es
            // La mise √† jour compl√®te sera g√©r√©e par updateOutput()
            
            // S'assurer que la classe 'updating' est retir√©e
            output.classList.remove('updating');
            
            // Force un reflow pour garantir la mise √† jour imm√©diate
            output.style.display = 'none';
            void output.offsetHeight;
            output.style.display = '';
            
            // Appeler updateOutput pour assurer que les dimensions des cartes sont affich√©es
            if (output.textContent === '') {
                updateOutput(false);
            }
        }
        
        // Fonction mise √† jour avec le nouveau format des variables standardis√©es
        function updateOutput(instant = false) {
            // Commencer par r√©cup√©rer le type de tirage actif pour les manipulations visuelles
            const activeSpreadType = spreadSelect.value;
            
            // Durant le d√©placement d'une carte (instant = true), on n'affiche que les variables du tirage actif
            // pour une meilleure performance, sinon on affiche tout
            const showOnlyActiveSpread = instant && selectedCard;
            
            // Variables pour suivre les modifications
            let hasChangedValues = false;
            let css = "";
            
            // Traitement des dimensions des cartes
            const spreadType = activeSpreadType;
            
            // Toujours afficher les dimensions courantes des cartes en premier
            css += `/* Dimensions des cartes pour le tirage ${spreads[spreadType].name} */\n`;
            css += `--${spreadType}-card-base-width: ${cardBaseWidth.value}px;\n`;
            css += `--${spreadType}-card-ratio: ${cardRatio.value};\n`;
            css += `--${spreadType}-card-scale-factor: ${cardScaleFactor.value};\n\n`;
            
            hasChangedValues = true;
            
            // Parcourir tous les types de tirages disponibles
            for (const spreadType in spreads) {
                // Si on est en mode d√©placement, on n'affiche que le tirage actif
                if (showOnlyActiveSpread && spreadType !== activeSpreadType) continue;
                
                // Collecter les variables modifi√©s pour ce tirage
                let spreadChanges = "";
                let hasChangesInThisSpread = false;
                
                // Parcourir les cartes pour ce tirage
                for (const card of spreads[spreadType].cards) {
                    // V√©rifier si la position existe dans cardPositions et initialCardPositions
                    if (!cardPositions[spreadType] || 
                        !cardPositions[spreadType][card.name] || 
                        !initialCardPositions[spreadType] || 
                        !initialCardPositions[spreadType][card.name]) {
                        continue;
                    }
                    
                    const pos = cardPositions[spreadType][card.name];
                    const initialPos = initialCardPositions[spreadType][card.name];
                    
                    // V√©rifier si les valeurs de x, y ou rotation ont chang√©
                    let positionCSS = "";
                    
                    // V√©rifier si x a chang√©
                    if (hasChanged(Math.round(pos.x), Math.round(initialPos.x))) {
                        positionCSS += `--${spreadType}-position-${card.position}-x: ${Math.round(pos.x)}%;\n`;
                    }
                    
                    // V√©rifier si y a chang√©
                    if (hasChanged(Math.round(pos.y), Math.round(initialPos.y))) {
                        positionCSS += `--${spreadType}-position-${card.position}-y: ${Math.round(pos.y)}%;\n`;
                    }
                    
                    // V√©rifier si rotation a chang√©
                    const rotation = pos.rotation || 0;
                    const initialRotation = initialPos.rotation || 0;
                    if (hasChanged(rotation, initialRotation)) {
                        positionCSS += `--${spreadType}-position-${card.position}-rotation: ${rotation}deg;\n`;
                    }
                    
                    // Si au moins une propri√©t√© a chang√©, ajouter √† spreadChanges
                    if (positionCSS) {
                        spreadChanges += positionCSS;
                        hasChangesInThisSpread = true;
                    }
                }
                
                // N'ajouter le commentaire du tirage que si des modifications ont √©t√© faites
                if (hasChangesInThisSpread) {
                    css += `/* Variables modifi√©es pour le tirage ${spreads[spreadType].name} */\n`;
                    css += spreadChanges;
                }
            }
            
            // Mise √† jour du texte de la zone d'affichage principale
            output.textContent = css;
            
            // Si besoin d'une mise √† jour imm√©diate, forcer un reflow
            if (instant) {
                // Technique standard pour forcer un reflow
                output.style.display = 'none';
                void output.offsetHeight; // Force reflow
                output.style.display = '';
            }
        }

        /**
         * Initialise l'application
         * Configure les √©couteurs d'√©v√©nements et charge le premier tirage
         */
        function initApp() {
            // √âcouteurs d'√©v√©nements principaux
            spreadSelect.addEventListener('change', function() {
                // S'assurer de charger d'abord les dimensions du spread s√©lectionn√©
                const newSpreadType = this.value;
                console.log(`Changement de tirage vers ${newSpreadType}`);
                
                // Charger explicitement les dimensions des cartes pour ce tirage sp√©cifique
                loadCardDimensionsFromCSS();
                
                // Puis charger le nouveau spread avec les dimensions correctes
                loadSpread();
                
                // Force une mise √† jour de l'affichage CSS √† la fin
                updateOutput(false);
            });
            
            document.getElementById('resetBtn').addEventListener('click', () => {
                // Charger les positions depuis variables.css au lieu de simplement vider
                loadInitialPositions();
                loadSpread();
                // Notifier l'utilisateur
                alert('Toutes les positions et dimensions ont √©t√© r√©initialis√©es aux valeurs de variables.css');
            });

            // √âcouter les changements de taille d'√©cran
            window.addEventListener('resize', function() {
                // Utiliser un debounce pour √©viter trop d'appels
                clearTimeout(window.resizeTimer);
                window.resizeTimer = setTimeout(applyCardDimensions, 250);
            });

            // Charger les positions initiales depuis variables.css
            loadInitialPositions();
            
            // Charger le premier tirage
            loadSpread();

            // Adapter la fonction copyBtn pour ajouter une explication
            document.getElementById('copyBtn').addEventListener('click', function() {
                // Utiliser directement le contenu de la zone d'affichage qui contient d√©j√† les variables modifi√©es
                const modifiedCss = output.textContent;
                
                if (modifiedCss.trim() === '' || modifiedCss.includes('S√©lectionnez et d√©placez les cartes')) {
                    alert('Aucune modification √† copier. D√©placez au moins une carte pour g√©n√©rer du CSS.');
                    return;
                }
                
                // Copier dans le presse-papier avec gestion d'erreur am√©lior√©e
                navigator.clipboard.writeText(modifiedCss)
                    .then(() => {
                        alert('CSS copi√© avec succ√®s');
                    })
                    .catch(err => {
                        console.error('Erreur lors de la copie: ', err);
                        alert('Erreur lors de la copie. Essayez de copier manuellement: Ctrl+A puis Ctrl+C');
                        
                        // S√©lectionner le texte pour faciliter la copie manuelle
                        const range = document.createRange();
                        range.selectNodeContents(output);
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                    });
            });
        }
        
        // D√©marrer l'application
        initApp();
    </script>
</body>
</html> 